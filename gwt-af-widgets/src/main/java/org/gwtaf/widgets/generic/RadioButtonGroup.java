/* * Copyright 2008. Mount Sinai Hospital, Toronto, Canada. *  * Licensed under the Apache License, Version 2.0. You * can find a copy of the license at: *  * http://www.apache.org/licenses/LICENSE-2.0 *  * IN NO EVENT SHALL MOUNT SINAI HOSPITAL BE LIABLE TO ANY PARTY FOR DIRECT,  * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST  * PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,  * EVEN IF MOUNT SINAI HOSPITAL HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE. *  * MOUNT SINAI HOSPITAL SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE AND  * ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS".  * MOUNT SINAI HOSPITAL HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,  * UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */package org.gwtaf.widgets.generic;import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import com.google.gwt.event.dom.client.ChangeEvent;import com.google.gwt.event.dom.client.ChangeHandler;import com.google.gwt.event.dom.client.ClickEvent;import com.google.gwt.event.dom.client.ClickHandler;import com.google.gwt.event.dom.client.HasChangeHandlers;import com.google.gwt.event.dom.client.HasClickHandlers;import com.google.gwt.event.logical.shared.ValueChangeEvent;import com.google.gwt.event.logical.shared.ValueChangeHandler;import com.google.gwt.event.shared.HandlerRegistration;import com.google.gwt.user.client.ui.Composite;import com.google.gwt.user.client.ui.HasValue;import com.google.gwt.user.client.ui.Panel;import com.google.gwt.user.client.ui.RadioButton;import com.google.inject.Provider;/** * A collection of radio buttons given some choices in a String[]. This class * also provides an easy way to get to individual radios based on their name. *  * @author Arthur Kalmenson * @author Sergey Vesselov */public class RadioButtonGroup extends Composite implements HasValue<String>,		HasClickHandlers, HasChangeHandlers {	/**	 * A map of question to radio button.	 */	protected Map<String, RadioButton> choiceToRadio = new HashMap<String, RadioButton>();	/**	 * The main panel.	 */	protected Panel mainPanel;	/**	 * The provider of {@link RadioButton}s.	 */	private Provider<RadioButton> radioButtonProvider;	/**	 * Creates a new collection of {@link RadioButton}s given	 * <code>choices</code> and a common <code>name</code> and a	 * <code>panel</code> for layout. If any arguments are null or the name is	 * empty, an {@link IllegalArgumentException} is thrown.	 * 	 * @param panel	 *            the concrete {@link Panel} to use for the collection.	 * @param choices	 *            list of choices offered in the collection.	 */	public RadioButtonGroup(Panel panel,			Provider<RadioButton> radioButtonProvider) {		// check arguments.		if (panel == null || radioButtonProvider == null) {			throw new IllegalArgumentException(getClass().getName()					+ ": Constructor arguments must all be instantiated.");		}		this.mainPanel = panel;		this.radioButtonProvider = radioButtonProvider;		initWidget(mainPanel);	}	public void setChoices(String[] choices) {		// make a new radio button for each choice we are given		for (String choice : choices) {			// create the radio button, add some style to it and add our custom			// click listener to catch clicks.			RadioButton radio = radioButtonProvider.get();			radio.setText(choice);			choiceToRadio.put(choice, radio);			mainPanel.add(radio);		}	}	/**	 * Returns a reference of the radio button with the provided choice	 * 	 * @param choice	 *            the choice of the button to be returned	 * @return the radio button with specified choice.	 */	public RadioButton getRadio(String choice) {		return choiceToRadio.get(choice);	}	/**	 * Returns true if at least one radio in this group is checked.	 * 	 * @return true if at least one radio in this group is checked.	 */	public boolean isChecked() {		boolean set = false;		// if any are checked, that means the group is checked.		for (RadioButton radio : choiceToRadio.values()) {			if (radio.getValue()) {				set = true;				break;			}		}		return set;	}	public String getValue() {		String result = null;		// find the radio button that's checked, and get it's text.		for (Entry<String, RadioButton> element : choiceToRadio.entrySet()) {			if (element.getValue().getValue()) {				result = element.getKey();				break;			}		}		return result;	}	public void setValue(String value) {		RadioButton buttonToCheck = choiceToRadio.get(value);		// check buttonToCheck and uncheck the previous one.		if (buttonToCheck != null) {			RadioButton checked = getRadio(getValue());			if (checked != null) {				checked.setValue(false);			}			buttonToCheck.setValue(true);		}	}	public void setValue(String arg0, boolean arg1) {		setValue(arg0);		ValueChangeEvent.fire(RadioButtonGroup.this, getValue());	}	/**	 * Returns the number of {@link RadioButton} this collection has.	 * 	 * @return the number of {@link RadioButton} this collection has.	 */	public int size() {		return choiceToRadio.size();	}	public HandlerRegistration addClickHandler(ClickHandler arg0) {		return addDomHandler(arg0, ClickEvent.getType());	}	public HandlerRegistration addValueChangeHandler(			ValueChangeHandler<String> handler) {		addChangeHandler(new ChangeHandler() {			public void onChange(ChangeEvent event) {				ValueChangeEvent.fire(RadioButtonGroup.this, getValue());			}		});		return addHandler(handler, ValueChangeEvent.getType());	}	public HandlerRegistration addChangeHandler(ChangeHandler arg0) {		return addDomHandler(arg0, ChangeEvent.getType());	}}